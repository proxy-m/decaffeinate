"use strict";
exports.__esModule = true;
var nodes_1 = require("decaffeinate-coffeescript2/lib/coffeescript/nodes");
var nodes_2 = require("../nodes");
var getLocation_1 = require("../util/getLocation");
var makeHeregex_1 = require("../util/makeHeregex");
var makeString_1 = require("../util/makeString");
var parseNumber_1 = require("../util/parseNumber");
var parseRegExp_1 = require("../util/parseRegExp");
var HEREGEX_PATTERN = /^\/\/\/((?:.|\s)*)\/\/\/([gimuy]*)$/;
function mapLiteral(context, node) {
    var _a = getLocation_1["default"](context, node), line = _a.line, column = _a.column, start = _a.start, end = _a.end, raw = _a.raw;
    if (node instanceof nodes_1.ThisLiteral) {
        return new nodes_2.This(line, column, start, end, raw);
    }
    else if (node instanceof nodes_1.NullLiteral) {
        return new nodes_2.Null(line, column, start, end, raw);
    }
    else if (node instanceof nodes_1.UndefinedLiteral) {
        return new nodes_2.Undefined(line, column, start, end, raw);
    }
    else if (node instanceof nodes_1.BooleanLiteral) {
        return new nodes_2.Bool(line, column, start, end, raw, JSON.parse(node.value));
    }
    else if (node instanceof nodes_1.IdentifierLiteral ||
        node instanceof nodes_1.PropertyName) {
        // Sometimes the CoffeeScript AST contains a string object instead of a
        // string primitive. Convert to string primitive if necessary.
        var value = node.value.valueOf();
        return new nodes_2.Identifier(line, column, start, end, raw, value);
    }
    else if (node instanceof nodes_1.PassthroughLiteral) {
        return new nodes_2.JavaScript(line, column, start, end, raw, node.value);
    }
    else if (node instanceof nodes_1.NumberLiteral) {
        if (raw.includes('.')) {
            return new nodes_2.Float(line, column, start, end, raw, parseNumber_1["default"](node.value));
        }
        else {
            return new nodes_2.Int(line, column, start, end, raw, parseNumber_1["default"](node.value));
        }
    }
    else if (node instanceof nodes_1.RegexLiteral) {
        var heregexMatch = raw.match(HEREGEX_PATTERN);
        if (heregexMatch) {
            var flags = heregexMatch[2];
            return makeHeregex_1["default"](context, node, flags);
        }
        else {
            var regExp = parseRegExp_1["default"](node.value);
            return new nodes_2.Regex(line, column, start, end, raw, regExp.pattern, nodes_2.RegexFlags.parse(regExp.flags || ''));
        }
    }
    else if (node instanceof nodes_1.StringLiteral) {
        return makeString_1["default"](context, node);
    }
    else if (node instanceof nodes_1.StatementLiteral) {
        if (node.value === 'break') {
            return new nodes_2.Break(line, column, start, end, raw);
        }
        else if (node.value === 'continue') {
            return new nodes_2.Continue(line, column, start, end, raw);
        }
    }
    throw new Error("Unexpected literal: " + JSON.stringify(node));
}
exports["default"] = mapLiteral;
