"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const t = require("@babel/types");
const traverse_1 = require("@babel/traverse");
function process(source, ast) {
    const tokens = ast.tokens;
    const insertions = [];
    const removals = [];
    traverse_1.default(ast, {
        VariableDeclaration(path) {
            const { node, parent } = path;
            const isForInit = ((t.isForStatement(parent) && parent.init === node) ||
                ((t.isForInStatement(parent) || t.isForOfStatement(parent)) && parent.left === node));
            if (!isForInit) {
                checkForSemicolon(node);
            }
        },
        ExpressionStatement(path) {
            checkForSemicolon(path.node);
        },
        ReturnStatement(path) {
            checkForSemicolon(path.node);
        },
        ThrowStatement(path) {
            checkForSemicolon(path.node);
        },
        DoWhileStatement(path) {
            checkForSemicolon(path.node);
        },
        DebuggerStatement(path) {
            checkForSemicolon(path.node);
        },
        BreakStatement(path) {
            checkForSemicolon(path.node);
        },
        ContinueStatement(path) {
            checkForSemicolon(path.node);
        },
        ImportDeclaration(path) {
            checkForSemicolon(path.node);
        },
        ExportAllDeclaration(path) {
            checkForSemicolon(path.node);
        },
        ExportNamedDeclaration(path) {
            if (!path.node.declaration) {
                checkForSemicolon(path.node);
            }
        },
        ExportDefaultDeclaration(path) {
            const { node } = path;
            const { declaration } = node;
            if (t.isClassDeclaration(declaration) || t.isFunctionDeclaration(declaration)) {
                if (!declaration.id) {
                    checkForSemicolon(node);
                }
            }
            else {
                checkForSemicolon(node);
            }
        },
        EmptyStatement(path) {
            const { node, parent } = path;
            if (!t.isForStatement(parent) &&
                !t.isForOfStatement(parent) &&
                !t.isForInStatement(parent) &&
                !t.isWhileStatement(parent) &&
                !t.isDoWhileStatement(parent)) {
                remove(startOfNode(node), endOfNode(node));
            }
        },
        ClassBody(path) {
            checkClassBodyForSemicolon(tokenAfterToken(firstTokenOfNode(path.node)));
        },
        ClassMethod(path) {
            checkClassBodyForSemicolon(tokenAfterToken(lastTokenOfNode(path.node)));
        }
    });
    return { insertions, removals };
    /**
     * Checks a node to see if it's followed by a semicolon.
     */
    function checkForSemicolon(node) {
        const lastToken = lastTokenOfNode(node);
        if (sourceOfToken(lastToken) !== ';') {
            insert(endOfToken(lastToken), ';');
        }
    }
    /**
     * Class bodies don't need semicolons.
     */
    function checkClassBodyForSemicolon(token) {
        while (token) {
            const source = sourceOfToken(token);
            if (source === ';') {
                remove(startOfToken(token), endOfToken(token));
            }
            else {
                break;
            }
            token = tokenAfterToken(token);
        }
    }
    function firstTokenOfNode(node) {
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token.start === node.start) {
                return token;
            }
        }
        throw new Error(`cannot find first token for node ${node.type} at ` +
            `${node.loc.start.line}:${node.loc.start.column + 1}`);
    }
    function lastTokenOfNode(node) {
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token.end === node.end) {
                return token;
            }
        }
        throw new Error(`cannot find last token for node ${node.type} at ` +
            `${node.loc.start.line}:${node.loc.start.column + 1}`);
    }
    function tokenAfterToken(token) {
        const index = tokens.indexOf(token);
        if (index < 0) {
            throw new Error(`cannot find token in tokens: ${JSON.stringify(token)}`);
        }
        return tokens[index + 1];
    }
    function sourceOfToken(token) {
        return source.slice(token.start, token.end);
    }
    function insert(index, content) {
        insertions.push({ index, content });
    }
    function remove(start, end) {
        removals.push({ start, end });
    }
    function startOfNode(node) {
        return node.start;
    }
    function endOfNode(node) {
        return node.end;
    }
    function startOfToken(token) {
        return token.start;
    }
    function endOfToken(token) {
        return token.end;
    }
}
exports.default = process;
