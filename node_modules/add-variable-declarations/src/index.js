"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var magic_string_1 = require("magic-string");
var TraverseState_1 = require("./utils/TraverseState");
var getBindingIdentifiersFromLHS_1 = require("./utils/getBindingIdentifiersFromLHS");
var lhsHasNonIdentifierAssignment_1 = require("./utils/lhsHasNonIdentifierAssignment");
var traverse_1 = require("@babel/traverse");
var t = require("@babel/types");
var parser_1 = require("@codemod/parser");
function addVariableDeclarations(source, editor, ast) {
    if (editor === void 0) { editor = new magic_string_1.default(source); }
    if (ast === void 0) { ast = parser_1.parse(source, { tokens: true }); }
    var state = null;
    var savedStates = [];
    var seen = new Set();
    function visitForStatement(path) {
        var e_1, _a;
        var state = getState();
        var node = path.node;
        var names = getBindingIdentifiersFromLHS_1.default(node.left).map(function (id) { return id.name; });
        if (lhsHasNonIdentifierAssignment_1.default(node.left)) {
            try {
                for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                    var name = names_1_1.value;
                    state.addBinding(name);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            state.addInlineBinding(node.left, names, { shouldRemoveParens: false });
        }
    }
    traverse_1.default(ast, {
        /**
         * Adds `var` for assignments, either in place or at the top of the scope.
         *
         *   a = 1;      // can add `var` inline
         *   b(c = 2);   // needs standalone `var` at the top of scope
         */
        AssignmentExpression: function (path) {
            var e_2, _a;
            var node = path.node;
            if (node.operator !== '=') {
                // Ignore e.g. `+=`.
                return;
            }
            if (seen.has(node)) {
                // We've already processed this one.
                return;
            }
            var state = getState();
            var names = getBindingIdentifiersFromLHS_1.default(node.left).map(function (id) { return id.name; });
            var canInsertVar = !lhsHasNonIdentifierAssignment_1.default(node.left) && (t.isExpressionStatement(path.parent) ||
                (t.isForStatement(path.parent) && node === path.parent.init));
            if (canInsertVar) {
                state.addInlineBinding(node, names, { shouldRemoveParens: true });
            }
            else {
                try {
                    for (var names_2 = __values(names), names_2_1 = names_2.next(); !names_2_1.done; names_2_1 = names_2.next()) {
                        var name = names_2_1.value;
                        state.addBinding(name);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (names_2_1 && !names_2_1.done && (_a = names_2.return)) _a.call(names_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        },
        /**
         * We want to declare each variable at its most specific scope across all
         * assignments and usages, so note each usage, since it might affect that
         * scope.
         */
        Identifier: function (path) {
            var state = getState();
            state.handleSeenIdentifier(path.node.name);
        },
        /**
         * Adds `var` to `for-in` and `for-of` loops, e.g.
         *
         *   for (key in object) {
         *     …
         *   }
         *
         *   for (item of list) {
         *     …
         *   }
         */
        ForInStatement: visitForStatement,
        ForOfStatement: visitForStatement,
        /**
         * Optimizes for the case where there are multiple assignments in one
         * sequence of expressions, e.g.
         *
         *   for (i = 0, length = list.length; i < length; i++) {
         *     …
         *   }
         */
        SequenceExpression: function (path) {
            var e_3, _a;
            var state = getState();
            var node = path.node;
            var names = [];
            if (!t.isExpressionStatement(path.parent) &&
                !(t.isForStatement(path.parent) && node === path.parent.init)) {
                return;
            }
            try {
                for (var _b = __values(node.expressions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expression = _c.value;
                    if (!t.isAssignmentExpression(expression)) {
                        return;
                    }
                    var identifiers = getBindingIdentifiersFromLHS_1.default(expression.left);
                    if (identifiers.length === 0) {
                        return;
                    }
                    if (lhsHasNonIdentifierAssignment_1.default(expression.left)) {
                        return;
                    }
                    names.push.apply(names, __spread(identifiers.map(function (identifier) { return identifier.name; })));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            state.addInlineBinding(node, names, { shouldRemoveParens: true });
            node.expressions.forEach(function (expression) { return seen.add(expression); });
        },
        enter: function (path) {
            if (t.isScopable(path.node)) {
                state = new TraverseState_1.default(path.scope, state);
            }
            // ObjectMethod and ClassMethod nodes are strange in that their key name
            // is in the outer scope, not the method scope, so we get the wrong scope
            // if we use the usual scope enter and exit hooks. To work around this,
            // pretend to be one scope higher while in the key, then restore the state
            // afterward.
            if ((t.isObjectMethod(path.parent) && path.key === 'key') ||
                (t.isClassMethod(path.parent) && path.key === 'key')) {
                savedStates.push(getState());
                state = getState().parentState;
            }
        },
        exit: function (path) {
            if (t.isScopable(path.node)) {
                if (state) {
                    state.commitDeclarations(editor, source, ast.tokens);
                    state = state.parentState;
                }
            }
            if ((t.isObjectMethod(path.parent) && path.key === 'key') ||
                (t.isClassMethod(path.parent) && path.key === 'key')) {
                state = savedStates.pop() || null;
            }
        },
    });
    function getState() {
        if (!state) {
            throw new Error('BUG: state is not set');
        }
        else {
            return state;
        }
    }
    return {
        code: editor.toString(),
        map: editor.generateMap()
    };
}
exports.default = addVariableDeclarations;
//# sourceMappingURL=index.js.map