"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultParserPlugins = new Set([
    'asyncGenerators',
    'bigInt',
    'classPrivateMethods',
    'classPrivateProperties',
    'classProperties',
    'doExpressions',
    'dynamicImport',
    'exportDefaultFrom',
    'exportNamespaceFrom',
    'functionBind',
    'functionSent',
    'importMeta',
    'jsx',
    'logicalAssignment',
    'nullishCoalescingOperator',
    'numericSeparator',
    'objectRestSpread',
    'optionalCatchBinding',
    'optionalChaining',
    'partialApplication',
    'placeholders',
    'throwExpressions',
    'topLevelAwait',
    ['decorators', { decoratorsBeforeExport: true }],
    ['pipelineOperator', { proposal: 'smart' }],
    ['recordAndTuple', { syntaxType: 'hash' }],
]);
/**
 * Builds options for `@babel/parser` by enabling as many features as possible,
 * while also preserving the options given as an argument.
 */
function buildOptions(_a = {}) {
    var { sourceType = 'unambiguous', allowAwaitOutsideFunction = true, allowImportExportEverywhere = true, allowReturnOutsideFunction = true, allowSuperOutsideMethod = true, allowUndeclaredExports = true, plugins = [], sourceFilename } = _a, rest = __rest(_a, ["sourceType", "allowAwaitOutsideFunction", "allowImportExportEverywhere", "allowReturnOutsideFunction", "allowSuperOutsideMethod", "allowUndeclaredExports", "plugins", "sourceFilename"]);
    for (const plugin of DefaultParserPlugins) {
        if (shouldAddPlugin(plugins, getPluginName(plugin))) {
            plugins = [...plugins, plugin];
        }
    }
    const typePlugin = typePluginForSourceFileName(sourceFilename);
    if (shouldAddPlugin(plugins, typePlugin)) {
        plugins = [...plugins, typePlugin];
    }
    return Object.assign({ sourceType,
        allowAwaitOutsideFunction,
        allowImportExportEverywhere,
        allowReturnOutsideFunction,
        allowSuperOutsideMethod,
        allowUndeclaredExports,
        plugins,
        sourceFilename }, rest);
}
exports.default = buildOptions;
/**
 * Gets plugins that cannot be enabled if the plugin given by `name` is enabled.
 *
 * @see https://github.com/babel/babel/blob/5fb4d84a33351c13057dc542513a3fe2309e08b0/packages/babel-parser/src/plugin-utils.js#L44-L49
 */
function getMutuallyExclusivePluginsForPlugin(name) {
    switch (name) {
        case 'flow':
        case 'flowComments':
            return ['typescript'];
        case 'typescript':
            return ['flow', 'flowComments'];
        case 'decorators':
            return ['decorators-legacy'];
        case 'decorators-legacy':
            return ['decorators'];
        default:
            return [];
    }
}
/**
 * Gets the type plugin to use for a given file name.
 *
 * @example
 *
 *   typePluginForSourceFileName('index.ts');  // 'typescript'
 *   typePluginForSourceFileName('index.jsx'); // 'flow'
 */
function typePluginForSourceFileName(sourceFileName) {
    if (typeof sourceFileName === 'string' && !/\.tsx?$/i.test(sourceFileName)) {
        return 'flow';
    }
    else {
        return 'typescript';
    }
}
/**
 * Determines whether a plugin list can accept a new plugin by name.
 *
 * @example
 *
 *   shouldAddPlugin([], 'jsx');                // true; existing list does not have "jsx"
 *   shouldAddPlugin(['jsx', 'bigInt'], 'jsx'); // false; existing list already has "jsx"
 *   shouldAddPlugin(['flow'], 'typescript');   // false; "typescript" is incompatible with "flow"
 */
function shouldAddPlugin(plugins, name) {
    if (pluginListIncludesPlugin(plugins, name)) {
        return false;
    }
    return !getMutuallyExclusivePluginsForPlugin(name).some((mutuallyExclusivePlugin) => pluginListIncludesPlugin(plugins, mutuallyExclusivePlugin));
}
/**
 * Checks `plugins` for an entry named `name`.
 *
 * @example
 *
 *   pluginListIncludesPlugin(['jsx', 'bigInt'], 'bigInt');              // true; list includes "bigInt" without options
 *   pluginListIncludesPlugin(['jsx', 'bigInt'], 'flow');                // false; list does not include "flow"
 *   pluginListIncludesPlugin(['jsx', ['flow', { all: true }]], 'flow'); // true; list includes "flow" with options
 */
function pluginListIncludesPlugin(plugins, name) {
    return plugins.some((entry) => getPluginName(entry) === name);
}
/**
 * Gets the name of `plugin`.
 *
 * @example
 *
 *   getPluginName('decorators');            // 'decorators'
 *   getPluginName(['flow', { all: true }]); // 'flow'
 */
function getPluginName(plugin) {
    return typeof plugin === 'string' ? plugin : plugin[0];
}
//# sourceMappingURL=options.js.map