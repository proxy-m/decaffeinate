"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function replaceWithAndPreserveComments(path, nodeOrNodes) {
    if (Array.isArray(nodeOrNodes)) {
        const firstNode = nodeOrNodes[0];
        const lastNode = nodeOrNodes[nodeOrNodes.length - 1];
        if (firstNode) {
            copyLeadingComments(path.node, firstNode);
        }
        if (lastNode) {
            copyTrailingComments(path.node, lastNode);
        }
        registerDeclarations(path.scope, path.replaceWithMultiple(nodeOrNodes));
    }
    else {
        copyLeadingComments(path.node, nodeOrNodes);
        copyTrailingComments(path.node, nodeOrNodes);
        registerDeclarations(path.scope, path.replaceWith(nodeOrNodes));
    }
}
exports.replaceWithAndPreserveComments = replaceWithAndPreserveComments;
function registerDeclarations(scope, declarations) {
    for (const declaration of Array.isArray(declarations)
        ? declarations
        : [declarations]) {
        scope.registerDeclaration(declaration);
    }
}
function addTrailingComment(comment, to) {
    const comments = to.comments || (to.comments = []);
    comments.push(Object.assign({}, comment, { leading: false, trailing: true }));
    to.trailingComments = comments.filter(comment => comment.trailing);
}
exports.addTrailingComment = addTrailingComment;
function addLeadingComment(comment, to) {
    const comments = to.comments || (to.comments = []);
    comments.push(Object.assign({}, comment, { leading: true, trailing: false }));
    to.leadingComments = comments.filter(comment => comment.leading);
}
exports.addLeadingComment = addLeadingComment;
function addLeadingOrTrailingComment(comment, to) {
    if (comment.leading) {
        addLeadingComment(comment, to);
    }
    else if (comment.trailing) {
        addTrailingComment(comment, to);
    }
}
exports.addLeadingOrTrailingComment = addLeadingOrTrailingComment;
function copyComments(from, to, shouldCopy = () => true, addComment = addLeadingOrTrailingComment) {
    const fromComments = from.comments;
    if (!fromComments || fromComments.length === 0) {
        return;
    }
    for (const comment of fromComments.filter(shouldCopy)) {
        addComment(comment, to);
    }
}
exports.copyComments = copyComments;
function copyLeadingComments(from, to, addComment = addLeadingComment) {
    copyComments(from, to, comment => comment.leading === true, addComment);
}
exports.copyLeadingComments = copyLeadingComments;
function copyTrailingComments(from, to, addComment = addTrailingComment) {
    copyComments(from, to, comment => comment.trailing === true, addComment);
}
exports.copyTrailingComments = copyTrailingComments;
//# sourceMappingURL=index.js.map