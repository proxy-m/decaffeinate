"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const t = __importStar(require("@babel/types"));
const helper_comments_1 = require("@resugar/helper-comments");
function default_1({ types: t }) {
    return {
        name: '@resugar/codemod-functions-arrow',
        visitor: {
            FunctionExpression(path) {
                let { node, parent } = path;
                // Skip generator functions.
                if (node.generator) {
                    return;
                }
                // Only process anonymous functions.
                if (node.id) {
                    return;
                }
                // Only process functions with a single return statement.
                if (node.body.body.length !== 1) {
                    return;
                }
                // A directive like "use strict" is syntactically its own line, so if any
                // exist, we can't assume this is a single-line function.
                if (node.body.directives.length > 0) {
                    return;
                }
                // `new` can't be called on arrow functions.
                if (t.isNewExpression(parent) && parent.callee === node) {
                    return;
                }
                let [statement] = node.body.body;
                if (!t.isReturnStatement(statement) || !statement.argument) {
                    return;
                }
                // Skip functions referencing `this` or `arguments`.
                if (referencesThisOrArguments(path)) {
                    return;
                }
                rewriteBlocklessArrowFunction(path);
            },
            /**
             * Look for functions that are manually bound, e.g.
             *
             *   this.onclick = (function() {
             *     console.log('registering');
             *     this.register();
             *   }).bind(this);
             */
            CallExpression(path) {
                const parent = path.parentPath;
                const callee = path.get('callee');
                if (!callee.isMemberExpression()) {
                    return;
                }
                const object = callee.get('object');
                const property = callee.get('property');
                if (!object.isFunctionExpression() || object.node.id) {
                    return;
                }
                if (!property.isIdentifier() || property.node.name !== 'bind') {
                    return;
                }
                if (path.node.arguments.length !== 1 ||
                    !t.isThisExpression(path.node.arguments[0])) {
                    return;
                }
                if (referencesArguments(object)) {
                    return;
                }
                if (object.node.generator) {
                    return;
                }
                // `new` can't be called on arrow functions.
                if (parent.isNewExpression()) {
                    path.skip();
                    return;
                }
                helper_comments_1.replaceWithAndPreserveComments(path, t.arrowFunctionExpression(object.node.params, object.node.body, object.node.async));
            }
        }
    };
}
exports.default = default_1;
function referencesThisOrArguments(path) {
    let result = false;
    path.scope.traverse(path.node, {
        'FunctionDeclaration|FunctionExpression'(fnPath) {
            // Skip nested functions.
            fnPath.skip();
        },
        ThisExpression(thisPath) {
            result = true;
            thisPath.stop();
        },
        Identifier(identPath) {
            if (identPath.node.name === 'arguments') {
                result = true;
                identPath.stop();
            }
        }
    });
    return result;
}
function referencesArguments(path) {
    let result = false;
    path.scope.traverse(path.node, {
        Function(fnPath) {
            // Skip nested functions.
            fnPath.skip();
        },
        Identifier(identPath) {
            if (identPath.node.name === 'arguments') {
                result = true;
                identPath.stop();
            }
        }
    });
    return result;
}
function rewriteBlocklessArrowFunction(path) {
    let { node } = path;
    let [statement] = node.body.body;
    const firstStatement = path.get('body').get('body')[0];
    if (!firstStatement.isReturnStatement()) {
        return;
    }
    helper_comments_1.replaceWithAndPreserveComments(firstStatement, firstStatement.node.argument);
    helper_comments_1.replaceWithAndPreserveComments(path, t.arrowFunctionExpression(node.params, statement.argument, node.async));
}
//# sourceMappingURL=index.js.map