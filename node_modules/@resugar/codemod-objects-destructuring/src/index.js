"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const t = __importStar(require("@babel/types"));
function default_1({ types: t }) {
    return {
        name: '@resugar/codemod-objects-destructuring',
        visitor: {
            VariableDeclaration(path) {
                let { node } = path;
                for (let index = 0; index < node.declarations.length; index++) {
                    let elements = extractSequentialDestructurableElements(node.declarations, index);
                    if (elements.length !== 0) {
                        node.declarations.splice(index, elements.length, t.variableDeclarator(t.objectPattern(elements.map(declarator => t.objectProperty(declarator.id, declarator.id, false, true))), elements[0].init.object));
                    }
                }
            },
            AssignmentExpression(path) {
                if (!t.isExpressionStatement(path.parent)) {
                    return;
                }
                let { node } = path;
                let assignments = extractSequentialDestructurableElements([node]);
                if (assignments.length === 0) {
                    return;
                }
                path.replaceWith(t.assignmentExpression('=', t.objectPattern(assignments.map(assignment => t.objectProperty(t.identifier(assignment.left.name), t.identifier(assignment.left.name), false, true))), node.right.object));
            },
            SequenceExpression(path) {
                let { node: { expressions } } = path;
                for (let index = 0; index < expressions.length; index++) {
                    let assignments = extractSequentialDestructurableElements(expressions, index);
                    if (assignments.length > 0) {
                        expressions.splice(index, assignments.length, t.assignmentExpression('=', t.objectPattern(assignments.map(({ left }) => t.objectProperty(left, left, false, true))), assignments[0].right.object));
                    }
                }
                if (expressions.length === 1) {
                    path.replaceWith(expressions[0]);
                }
            }
        }
    };
}
exports.default = default_1;
function extractSequentialDestructurableElements(elements, start = 0) {
    const result = [];
    let destructurable;
    for (let i = start; i < elements.length; i++) {
        let element = elements[i];
        let leftRight = leftRightOfAssignment(element);
        if (!leftRight) {
            break;
        }
        let { left, right } = leftRight;
        if (!t.isIdentifier(left)) {
            break;
        }
        if (!right || !t.isMemberExpression(right)) {
            break;
        }
        if (right.computed) {
            break;
        }
        if (left.name !== right.property.name) {
            break;
        }
        if (destructurable) {
            if (!t.isIdentifier(right.object) ||
                right.object.name !== destructurable) {
                break;
            }
        }
        else if (t.isIdentifier(right.object)) {
            destructurable = right.object.name;
        }
        result.push(element);
        if (!t.isIdentifier(right.object)) {
            break;
        }
    }
    return result;
}
function leftRightOfAssignment(node) {
    if (t.isVariableDeclarator(node)) {
        return { left: node.id, right: node.init };
    }
    else if (t.isAssignmentExpression(node) && node.operator === '=') {
        return { left: node.left, right: node.right };
    }
    else {
        return null;
    }
}
function isSafeToConsolidate(node) {
    return t.isIdentifier(node);
}
//# sourceMappingURL=index.js.map