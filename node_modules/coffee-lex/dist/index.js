"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var SourceLocation_1 = require("./SourceLocation");
var SourceToken_1 = require("./SourceToken");
var SourceTokenList_1 = require("./SourceTokenList");
var SourceType_1 = require("./SourceType");
exports.SourceType = SourceType_1.default;
var BufferedStream_1 = require("./utils/BufferedStream");
var calculateHeregexpPadding_1 = require("./utils/calculateHeregexpPadding");
var calculateNormalStringPadding_1 = require("./utils/calculateNormalStringPadding");
var calculateTripleQuotedStringPadding_1 = require("./utils/calculateTripleQuotedStringPadding");
var ContextType;
(function (ContextType) {
    ContextType["STRING"] = "STRING";
    ContextType["INTERPOLATION"] = "INTERPOLATION";
    ContextType["CSX_OPEN_TAG"] = "CSX_OPEN_TAG";
    ContextType["CSX_CLOSE_TAG"] = "CSX_CLOSE_TAG";
    ContextType["CSX_BODY"] = "CSX_BODY";
    ContextType["BRACE"] = "BRACE";
    ContextType["PAREN"] = "PAREN";
})(ContextType || (ContextType = {}));
exports.DEFAULT_OPTIONS = {
    useCS2: false
};
/**
 * Generate a list of tokens from CoffeeScript source code.
 */
function lex(source, options) {
    if (options === void 0) { options = exports.DEFAULT_OPTIONS; }
    var location;
    var previousLocation;
    var tokens = [];
    var pending = new BufferedStream_1.default(stream(source, 0, options));
    do {
        pending.unshift.apply(pending, calculateNormalStringPadding_1.default(source, pending));
        pending.unshift.apply(pending, calculateTripleQuotedStringPadding_1.default(source, pending));
        pending.unshift.apply(pending, calculateHeregexpPadding_1.default(source, pending));
        pending.unshift.apply(pending, combinedLocationsForNegatedOperators(pending, source));
        location = pending.shift();
        if (previousLocation && previousLocation.type !== SourceType_1.default.SPACE) {
            tokens.push(new SourceToken_1.default(previousLocation.type, previousLocation.index, location.index));
        }
        previousLocation = location;
    } while (location.type !== SourceType_1.default.EOF);
    return new SourceTokenList_1.default(tokens);
}
exports.default = lex;
function combinedLocationsForNegatedOperators(stream, source) {
    if (!stream.hasNext(SourceType_1.default.OPERATOR)) {
        return [];
    }
    var locationsToRestore = [];
    function shift() {
        var location = stream.shift();
        locationsToRestore.push(location);
        return location;
    }
    var not = shift();
    var space = shift();
    var text = source.slice(not.index, space.index);
    var operator;
    if (text === 'not') {
        if (space.type === SourceType_1.default.SPACE) {
            // It is a space, so the operator is at the next location.
            operator = shift();
        }
        else {
            // `not` must be followed by a space, so this isn't a match.
            return locationsToRestore;
        }
    }
    else if (text === '!') {
        if (space.type === SourceType_1.default.SPACE) {
            // It is a space, so the operator is at the next location.
            operator = shift();
        }
        else {
            // The optional space is missing, so the next thing must be the operator.
            operator = space;
        }
    }
    else {
        // Not a negation token, so put them back.
        return locationsToRestore;
    }
    var next = stream.peek();
    var op = source.slice(operator.index, next.index);
    switch (op) {
        case 'in':
        case 'of':
            return [new SourceLocation_1.default(SourceType_1.default.RELATION, not.index)];
        case 'instanceof':
            return [new SourceLocation_1.default(SourceType_1.default.OPERATOR, not.index)];
    }
    // Doesn't match, so put them back.
    return locationsToRestore;
}
var REGEXP_FLAGS = ['i', 'g', 'm', 'u', 'y'];
/**
 * Borrowed, with tweaks, from CoffeeScript's lexer.coffee.
 */
var STRING = [
    SourceType_1.default.SSTRING_END,
    SourceType_1.default.DSTRING_END,
    SourceType_1.default.TSSTRING_END,
    SourceType_1.default.TDSTRING_END
];
var CALLABLE = [
    SourceType_1.default.IDENTIFIER,
    SourceType_1.default.CALL_END,
    SourceType_1.default.RPAREN,
    SourceType_1.default.RBRACKET,
    SourceType_1.default.EXISTENCE,
    SourceType_1.default.AT,
    SourceType_1.default.THIS,
    SourceType_1.default.SUPER
];
var INDEXABLE = CALLABLE.concat(__spreadArrays([
    SourceType_1.default.NUMBER
], STRING, [
    SourceType_1.default.REGEXP,
    SourceType_1.default.HEREGEXP_END,
    SourceType_1.default.BOOL,
    SourceType_1.default.NULL,
    SourceType_1.default.UNDEFINED,
    SourceType_1.default.RBRACE,
    SourceType_1.default.PROTO
]));
var NOT_REGEXP = INDEXABLE.concat([
    SourceType_1.default.INCREMENT,
    SourceType_1.default.DECREMENT
]);
var IDENTIFIER_PATTERN = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)/;
// Like identifier, but includes '-' and '.'.
var CSX_IDENTIFIER_PATTERN = /^(?!\d)((?:(?!\s)[.\-$\w\x7f-\uffff])+)/;
var NUMBER_PATTERN = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
var SPACE_PATTERN = /^[^\n\r\S]+/;
var REGEXP_PATTERN = /^\/(?!\/)((?:[^[/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;
var YIELDFROM_PATTERN = /^yield[^\n\r\S]+from/;
var OPERATORS = [
    // equality
    '===',
    '==',
    '!==',
    '!=',
    // assignment
    '=',
    '+=',
    '-=',
    '/=',
    '*=',
    '%=',
    '%%=',
    '||=',
    '&&=',
    '^=',
    'or=',
    'and=',
    '?=',
    '|=',
    '&=',
    '~=',
    '<<=',
    '>>>=',
    '>>=',
    // increment/decrement
    '++',
    '--',
    // math
    '+',
    '-',
    '//',
    '/',
    '*',
    '%',
    '%%',
    // logical
    '||',
    '&&',
    '^',
    '!',
    // existence
    '?',
    // bitwise
    '|',
    '&',
    '~',
    '<<',
    '>>>',
    '>>',
    // comparison
    '<=',
    '<',
    '>=',
    '>',
    // prototype access
    '::'
];
/**
 * Provides a stream of source type change locations.
 */
function stream(source, index, options) {
    if (index === void 0) { index = 0; }
    if (options === void 0) { options = exports.DEFAULT_OPTIONS; }
    var location = new SourceLocation_1.default(SourceType_1.default.NORMAL, index);
    var contextStack = [];
    var start = index;
    var locations = [];
    function currentContext() {
        return contextStack[contextStack.length - 1] || null;
    }
    function currentContextType() {
        var context = currentContext();
        return context ? context.type : null;
    }
    return function step() {
        var lastLocation = location;
        var shouldStepAgain = false;
        do {
            start = index;
            if (index >= source.length) {
                setType(SourceType_1.default.EOF);
            }
            switch (location.type) {
                case SourceType_1.default.NORMAL:
                case SourceType_1.default.SPACE:
                case SourceType_1.default.IDENTIFIER:
                case SourceType_1.default.DOT:
                case SourceType_1.default.NUMBER:
                case SourceType_1.default.OPERATOR:
                case SourceType_1.default.INCREMENT:
                case SourceType_1.default.DECREMENT:
                case SourceType_1.default.COMMA:
                case SourceType_1.default.LPAREN:
                case SourceType_1.default.RPAREN:
                case SourceType_1.default.CALL_START:
                case SourceType_1.default.CALL_END:
                case SourceType_1.default.NEW:
                case SourceType_1.default.LBRACE:
                case SourceType_1.default.RBRACE:
                case SourceType_1.default.LBRACKET:
                case SourceType_1.default.RBRACKET:
                case SourceType_1.default.NEWLINE:
                case SourceType_1.default.COLON:
                case SourceType_1.default.FUNCTION:
                case SourceType_1.default.THIS:
                case SourceType_1.default.AT:
                case SourceType_1.default.SEMICOLON:
                case SourceType_1.default.IF:
                case SourceType_1.default.ELSE:
                case SourceType_1.default.THEN:
                case SourceType_1.default.FOR:
                case SourceType_1.default.OWN:
                case SourceType_1.default.WHILE:
                case SourceType_1.default.BOOL:
                case SourceType_1.default.NULL:
                case SourceType_1.default.UNDEFINED:
                case SourceType_1.default.REGEXP:
                case SourceType_1.default.SSTRING_END:
                case SourceType_1.default.DSTRING_END:
                case SourceType_1.default.TSSTRING_END:
                case SourceType_1.default.TDSTRING_END:
                case SourceType_1.default.INTERPOLATION_START:
                case SourceType_1.default.SUPER:
                case SourceType_1.default.TRY:
                case SourceType_1.default.CATCH:
                case SourceType_1.default.FINALLY:
                case SourceType_1.default.SWITCH:
                case SourceType_1.default.WHEN:
                case SourceType_1.default.BREAK:
                case SourceType_1.default.CONTINUE:
                case SourceType_1.default.EXISTENCE:
                case SourceType_1.default.CLASS:
                case SourceType_1.default.PROTO:
                case SourceType_1.default.RANGE:
                case SourceType_1.default.DELETE:
                case SourceType_1.default.RETURN:
                case SourceType_1.default.RELATION:
                case SourceType_1.default.LOOP:
                case SourceType_1.default.DO:
                case SourceType_1.default.YIELD:
                case SourceType_1.default.YIELDFROM:
                case SourceType_1.default.THROW:
                case SourceType_1.default.EXTENDS:
                case SourceType_1.default.IMPORT:
                case SourceType_1.default.EXPORT:
                case SourceType_1.default.DEFAULT:
                case SourceType_1.default.CSX_OPEN_TAG_START:
                case SourceType_1.default.CSX_CLOSE_TAG_START:
                case SourceType_1.default.CONTINUATION:
                    if (consume(SPACE_PATTERN)) {
                        setType(SourceType_1.default.SPACE);
                    }
                    else if (consume('\n')) {
                        setType(SourceType_1.default.NEWLINE);
                    }
                    else if (consume('...') || consume('..')) {
                        setType(SourceType_1.default.RANGE);
                    }
                    else if (consume(NUMBER_PATTERN)) {
                        setType(SourceType_1.default.NUMBER);
                    }
                    else if (consume('.')) {
                        setType(SourceType_1.default.DOT);
                    }
                    else if (consume('"""')) {
                        contextStack.push({
                            type: ContextType.STRING,
                            allowComments: false,
                            allowInterpolations: true,
                            endingDelimiter: '"""',
                            endSourceType: SourceType_1.default.TDSTRING_END
                        });
                        setType(SourceType_1.default.TDSTRING_START);
                    }
                    else if (consume('"')) {
                        contextStack.push({
                            type: ContextType.STRING,
                            allowComments: false,
                            allowInterpolations: true,
                            endingDelimiter: '"',
                            endSourceType: SourceType_1.default.DSTRING_END
                        });
                        setType(SourceType_1.default.DSTRING_START);
                    }
                    else if (consume("'''")) {
                        contextStack.push({
                            type: ContextType.STRING,
                            allowComments: false,
                            allowInterpolations: false,
                            endingDelimiter: "'''",
                            endSourceType: SourceType_1.default.TSSTRING_END
                        });
                        setType(SourceType_1.default.TSSTRING_START);
                    }
                    else if (consume("'")) {
                        contextStack.push({
                            type: ContextType.STRING,
                            allowComments: false,
                            allowInterpolations: false,
                            endingDelimiter: "'",
                            endSourceType: SourceType_1.default.SSTRING_END
                        });
                        setType(SourceType_1.default.SSTRING_START);
                    }
                    else if (consume(/^###[^#]/)) {
                        setType(SourceType_1.default.HERECOMMENT);
                    }
                    else if (consume('#')) {
                        setType(SourceType_1.default.COMMENT);
                    }
                    else if (consume('///')) {
                        contextStack.push({
                            type: ContextType.STRING,
                            allowComments: true,
                            allowInterpolations: true,
                            endingDelimiter: '///',
                            endSourceType: SourceType_1.default.HEREGEXP_END
                        });
                        setType(SourceType_1.default.HEREGEXP_START);
                    }
                    else if (consume('(')) {
                        if (CALLABLE.indexOf(location.type) >= 0) {
                            contextStack.push({
                                type: ContextType.PAREN,
                                sourceType: SourceType_1.default.CALL_START
                            });
                            setType(SourceType_1.default.CALL_START);
                        }
                        else {
                            contextStack.push({
                                type: ContextType.PAREN,
                                sourceType: SourceType_1.default.LPAREN
                            });
                            setType(SourceType_1.default.LPAREN);
                        }
                    }
                    else if (consume(')')) {
                        var context = contextStack.pop();
                        if (!context || context.type !== ContextType.PAREN) {
                            throw new Error("unexpected ')' at " + start);
                        }
                        var sourceType = context.sourceType;
                        switch (sourceType) {
                            case SourceType_1.default.LPAREN:
                                setType(SourceType_1.default.RPAREN);
                                break;
                            case SourceType_1.default.CALL_START:
                                setType(SourceType_1.default.CALL_END);
                                break;
                            default:
                                throw new Error("unexpected token type for '(' matching ')' at " + start + ": " + (sourceType ? sourceType.toString() : '??'));
                        }
                    }
                    else if (consume('[')) {
                        setType(SourceType_1.default.LBRACKET);
                    }
                    else if (consume(']')) {
                        setType(SourceType_1.default.RBRACKET);
                    }
                    else if (consume('{')) {
                        contextStack.push({ type: ContextType.BRACE });
                        setType(SourceType_1.default.LBRACE);
                    }
                    else if (consume('}')) {
                        if (currentContextType() === ContextType.INTERPOLATION) {
                            popInterpolation();
                        }
                        else if (currentContextType() === ContextType.BRACE) {
                            contextStack.pop();
                            setType(SourceType_1.default.RBRACE);
                        }
                        else {
                            throw new Error("Unexpected context type: " + currentContextType());
                        }
                    }
                    else if (consumeCSXOpenTagStart()) {
                        contextStack.push({ type: ContextType.CSX_OPEN_TAG });
                        setType(SourceType_1.default.CSX_OPEN_TAG_START);
                    }
                    else if (currentContextType() === ContextType.CSX_OPEN_TAG &&
                        consume('>')) {
                        contextStack.pop();
                        setType(SourceType_1.default.CSX_OPEN_TAG_END);
                    }
                    else if (currentContextType() === ContextType.CSX_OPEN_TAG &&
                        consume('/>')) {
                        contextStack.pop();
                        setType(SourceType_1.default.CSX_SELF_CLOSING_TAG_END);
                    }
                    else if (currentContextType() === ContextType.CSX_CLOSE_TAG &&
                        consume('>')) {
                        contextStack.pop();
                        setType(SourceType_1.default.CSX_CLOSE_TAG_END);
                    }
                    else if (consumeAny(['->', '=>'])) {
                        setType(SourceType_1.default.FUNCTION);
                    }
                    else if (consumeRegexp()) {
                        setType(SourceType_1.default.REGEXP);
                    }
                    else if (consume('::')) {
                        setType(SourceType_1.default.PROTO);
                    }
                    else if (consume(':')) {
                        setType(SourceType_1.default.COLON);
                    }
                    else if (consume(',')) {
                        setType(SourceType_1.default.COMMA);
                    }
                    else if (consume('@')) {
                        setType(SourceType_1.default.AT);
                    }
                    else if (consume(';')) {
                        setType(SourceType_1.default.SEMICOLON);
                    }
                    else if (consume('```')) {
                        setType(SourceType_1.default.HEREJS);
                    }
                    else if (consume('`')) {
                        setType(SourceType_1.default.JS);
                    }
                    else if (consumeAny(OPERATORS)) {
                        if (consumed() === '?') {
                            setType(SourceType_1.default.EXISTENCE);
                        }
                        else if (consumed() === '++') {
                            setType(SourceType_1.default.INCREMENT);
                        }
                        else if (consumed() === '--') {
                            setType(SourceType_1.default.DECREMENT);
                        }
                        else {
                            setType(SourceType_1.default.OPERATOR);
                        }
                    }
                    else if (consume(YIELDFROM_PATTERN)) {
                        setType(SourceType_1.default.YIELDFROM);
                    }
                    else if (currentContextType() === ContextType.CSX_OPEN_TAG &&
                        consume(CSX_IDENTIFIER_PATTERN)) {
                        setType(SourceType_1.default.IDENTIFIER);
                    }
                    else if (consume(IDENTIFIER_PATTERN)) {
                        var prevLocationIndex = locations.length - 1;
                        while (prevLocationIndex > 0 &&
                            (locations[prevLocationIndex].type === SourceType_1.default.NEWLINE ||
                                locations[prevLocationIndex].type === SourceType_1.default.SPACE)) {
                            prevLocationIndex--;
                        }
                        var prev = locations[prevLocationIndex];
                        var nextIsColon = match(/^\s*:/);
                        if (nextIsColon ||
                            (prev &&
                                // i.e. `a.b` or `a.\nb`
                                (prev.type === SourceType_1.default.DOT ||
                                    // i.e. `a::b` or `a::\nb`
                                    prev.type === SourceType_1.default.PROTO ||
                                    // i.e. `@a` (but not `@\na`, since that's `this\na`â€“see #175)
                                    (prev.type === SourceType_1.default.AT &&
                                        prevLocationIndex === locations.length - 1)))) {
                            setType(SourceType_1.default.IDENTIFIER);
                        }
                        else {
                            switch (consumed()) {
                                case 'if':
                                case 'unless':
                                    setType(SourceType_1.default.IF);
                                    break;
                                case 'else':
                                    setType(SourceType_1.default.ELSE);
                                    break;
                                case 'return':
                                    setType(SourceType_1.default.RETURN);
                                    break;
                                case 'for':
                                    setType(SourceType_1.default.FOR);
                                    break;
                                case 'own':
                                    setType(SourceType_1.default.OWN);
                                    break;
                                case 'while':
                                case 'until':
                                    setType(SourceType_1.default.WHILE);
                                    break;
                                case 'loop':
                                    setType(SourceType_1.default.LOOP);
                                    break;
                                case 'then':
                                    setType(SourceType_1.default.THEN);
                                    break;
                                case 'switch':
                                    setType(SourceType_1.default.SWITCH);
                                    break;
                                case 'when':
                                    setType(SourceType_1.default.WHEN);
                                    break;
                                case 'null':
                                    setType(SourceType_1.default.NULL);
                                    break;
                                case 'undefined':
                                    setType(SourceType_1.default.UNDEFINED);
                                    break;
                                case 'this':
                                    setType(SourceType_1.default.THIS);
                                    break;
                                case 'new':
                                    setType(SourceType_1.default.NEW);
                                    break;
                                case 'super':
                                    setType(SourceType_1.default.SUPER);
                                    break;
                                case 'true':
                                case 'false':
                                case 'yes':
                                case 'no':
                                case 'on':
                                case 'off':
                                    setType(SourceType_1.default.BOOL);
                                    break;
                                case 'and':
                                case 'or':
                                case 'not':
                                case 'is':
                                case 'isnt':
                                case 'instanceof':
                                    setType(SourceType_1.default.OPERATOR);
                                    break;
                                case 'class':
                                    setType(SourceType_1.default.CLASS);
                                    break;
                                case 'break':
                                    setType(SourceType_1.default.BREAK);
                                    break;
                                case 'continue':
                                    setType(SourceType_1.default.CONTINUE);
                                    break;
                                case 'try':
                                    setType(SourceType_1.default.TRY);
                                    break;
                                case 'catch':
                                    setType(SourceType_1.default.CATCH);
                                    break;
                                case 'finally':
                                    setType(SourceType_1.default.FINALLY);
                                    break;
                                case 'delete':
                                    setType(SourceType_1.default.DELETE);
                                    break;
                                case 'in':
                                case 'of':
                                    setType(SourceType_1.default.RELATION);
                                    break;
                                case 'do':
                                    setType(SourceType_1.default.DO);
                                    break;
                                case 'yield':
                                    setType(SourceType_1.default.YIELD);
                                    break;
                                case 'throw':
                                    setType(SourceType_1.default.THROW);
                                    break;
                                case 'extends':
                                    setType(SourceType_1.default.EXTENDS);
                                    break;
                                case 'import':
                                    setType(SourceType_1.default.IMPORT);
                                    break;
                                case 'export':
                                    setType(SourceType_1.default.EXPORT);
                                    break;
                                case 'default':
                                    setType(SourceType_1.default.DEFAULT);
                                    break;
                                default:
                                    setType(SourceType_1.default.IDENTIFIER);
                            }
                        }
                    }
                    else if (consume('\\')) {
                        setType(SourceType_1.default.CONTINUATION);
                    }
                    else {
                        setType(SourceType_1.default.UNKNOWN);
                    }
                    break;
                case SourceType_1.default.SSTRING_START:
                case SourceType_1.default.DSTRING_START:
                case SourceType_1.default.TSSTRING_START:
                case SourceType_1.default.TDSTRING_START:
                case SourceType_1.default.HEREGEXP_START:
                    setType(SourceType_1.default.STRING_CONTENT);
                    break;
                case SourceType_1.default.STRING_CONTENT: {
                    var context = currentContext();
                    if (!context || context.type !== ContextType.STRING) {
                        throw new Error('Unexpected STRING_CONTENT without anything on the string stack.');
                    }
                    var allowComments = context.allowComments, allowInterpolations = context.allowInterpolations, endingDelimiter = context.endingDelimiter, endSourceType = context.endSourceType;
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume(endingDelimiter)) {
                        contextStack.pop();
                        setType(endSourceType);
                    }
                    else if (allowInterpolations && consume('#{')) {
                        pushInterpolation();
                    }
                    else if (options.useCS2 &&
                        allowComments &&
                        source[index - 1].match(/\s/) &&
                        match('#') &&
                        !match('#{')) {
                        setType(SourceType_1.default.HEREGEXP_COMMENT);
                    }
                    else {
                        index++;
                    }
                    break;
                }
                case SourceType_1.default.COMMENT:
                    if (consume('\n')) {
                        setType(SourceType_1.default.NEWLINE);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1.default.HERECOMMENT:
                    if (consume('###')) {
                        setType(SourceType_1.default.NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1.default.HEREGEXP_COMMENT:
                    if (consume('\n')) {
                        setType(SourceType_1.default.STRING_CONTENT);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1.default.INTERPOLATION_END: {
                    var context = contextStack.pop();
                    if (!context || context.type !== ContextType.INTERPOLATION) {
                        throw new Error("found interpolation end without any interpolation start");
                    }
                    setType(context.interpolationType);
                    break;
                }
                case SourceType_1.default.HEREGEXP_END:
                    while (consumeAny(REGEXP_FLAGS)) {
                        // condition has side-effect
                    }
                    setType(SourceType_1.default.NORMAL);
                    break;
                case SourceType_1.default.JS:
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume('`')) {
                        setType(SourceType_1.default.NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1.default.HEREJS:
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume('```')) {
                        setType(SourceType_1.default.NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1.default.CSX_OPEN_TAG_END:
                    setType(SourceType_1.default.CSX_BODY);
                    contextStack.push({ type: ContextType.CSX_BODY });
                    break;
                case SourceType_1.default.CSX_BODY: {
                    if (consume('</')) {
                        contextStack.pop();
                        setType(SourceType_1.default.CSX_CLOSE_TAG_START);
                        contextStack.push({ type: ContextType.CSX_CLOSE_TAG });
                    }
                    else if (consumeCSXOpenTagStart()) {
                        setType(SourceType_1.default.CSX_OPEN_TAG_START);
                        contextStack.push({ type: ContextType.CSX_OPEN_TAG });
                    }
                    else if (consume('{')) {
                        pushInterpolation();
                    }
                    else {
                        index++;
                    }
                    break;
                }
                case SourceType_1.default.CSX_SELF_CLOSING_TAG_END:
                case SourceType_1.default.CSX_CLOSE_TAG_END:
                    if (currentContextType() === ContextType.CSX_BODY) {
                        setType(SourceType_1.default.CSX_BODY);
                    }
                    else {
                        setType(SourceType_1.default.NORMAL);
                    }
                    break;
                case SourceType_1.default.EOF: {
                    var context = currentContext();
                    if (context !== null) {
                        throw new Error("unexpected EOF while in context " + context.type);
                    }
                    break;
                }
                case SourceType_1.default.UNKNOWN:
                    // Jump to the end.
                    index = source.length;
                    break;
                default:
                    throw new Error("unknown source type at offset " + location.index + ": " + SourceType_1.default[location.type]);
            }
            shouldStepAgain =
                // Don't report on going back to "normal" source code.
                location.type === SourceType_1.default.NORMAL ||
                    // Don't report if nothing has changed, unless we're at the end.
                    (location === lastLocation && location.type !== SourceType_1.default.EOF);
        } while (shouldStepAgain);
        locations.push(location);
        return location;
    };
    function consumeAny(strings) {
        return strings.some(function (string) { return consume(string); });
    }
    function consume(value) {
        var matchData = match(value);
        if (matchData) {
            index += matchData[0].length;
            return true;
        }
        else {
            return false;
        }
    }
    function consumeRegexp() {
        var matchData = match(REGEXP_PATTERN);
        if (!matchData) {
            return false;
        }
        var regex = matchData[0], closed = matchData[2];
        var prev = locations[locations.length - 1];
        if (prev) {
            var spaced = false;
            if (prev.type === SourceType_1.default.SPACE) {
                spaced = true;
                prev = locations[locations.length - 2];
            }
            if (spaced && CALLABLE.indexOf(prev.type) >= 0) {
                if (!closed || /^\/=?\s/.test(regex)) {
                    return false;
                }
            }
            else if (NOT_REGEXP.indexOf(prev.type) >= 0) {
                return false;
            }
        }
        if (!closed) {
            throw new Error('missing / (unclosed regex)');
        }
        index += regex.length;
        while (consumeAny(REGEXP_FLAGS)) {
            // condition has side-effect
        }
        return true;
    }
    /**
     * CSX starts are identified by a less-than sign followed by a CSX identifier
     * or `<>` token (no space allowed after the less-than).
     *
     * We also bail in cases like `a<b`: if we're not already in a CSX context,
     * the less-than needs to be preceded by a space or a token other than identifier,
     * close-paren, close-bracket, or number.
     */
    function consumeCSXOpenTagStart() {
        if (!match('<')) {
            return false;
        }
        if (source[index + 1] !== '>' &&
            !source.slice(index + 1).match(CSX_IDENTIFIER_PATTERN)) {
            return false;
        }
        var contextType = currentContextType();
        if (contextType !== ContextType.CSX_BODY &&
            contextType !== ContextType.CSX_OPEN_TAG &&
            [
                SourceType_1.default.IDENTIFIER,
                SourceType_1.default.RPAREN,
                SourceType_1.default.RBRACKET,
                SourceType_1.default.NUMBER
            ].includes(location.type)) {
            return false;
        }
        consume('<');
        return true;
    }
    function consumed() {
        return source.slice(start, index);
    }
    function setType(newType) {
        location = new SourceLocation_1.default(newType, start);
    }
    function match(value) {
        if (typeof value === 'string') {
            var matches = source.slice(index, index + value.length) === value;
            return matches ? [value] : null;
        }
        else {
            return source.slice(index).match(value);
        }
    }
    function pushInterpolation() {
        contextStack.push({
            type: ContextType.INTERPOLATION,
            interpolationType: location.type
        });
        setType(SourceType_1.default.INTERPOLATION_START);
    }
    function popInterpolation() {
        if (currentContextType() !== ContextType.INTERPOLATION) {
            throw new Error("unexpected '}' found in string at " + index + ": " + JSON.stringify(source));
        }
        setType(SourceType_1.default.INTERPOLATION_END);
    }
}
exports.stream = stream;
function consumeStream(lexer) {
    var result = [];
    var location;
    do {
        location = lexer();
        result.push(location);
    } while (location.type !== SourceType_1.default.EOF);
    return result;
}
exports.consumeStream = consumeStream;
